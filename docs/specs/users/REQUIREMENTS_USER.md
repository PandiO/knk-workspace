# REQUIREMENTS: User / Player Account System (v2 API-aligned)

This document integrates:
- **Legacy feature analysis**: SPEC_USER.md (domain concepts from knk v1)
- **v2 API model**: User.cs, UserDtos.cs, UsersController.cs (desired architecture)
- **Business requirements**: Multilateral create flow, banking-grade currency handling
- **Stakeholder rules**: v2 deviations from legacy (separate Id/Uuid, dual currency, email support)

---

## Part A: User Entity Model (v2 Architecture)

### Core Identity & Profile

**Model Fields (from User.cs):**
```csharp
public int Id { get; set; }                          // Surrogate key; auto-generated by API
public string Username { get; set; }                 // Required; unique when combined with Uuid
public string Uuid { get; set; }                     // Nullable at creation; set on first Minecraft join
public string? Email { get; set; }                   // Optional; for web app accounts
public string? PasswordHash { get; set; }            // Optional; hashed password for web auth
public DateTime CreatedAt { get; set; }              // Set at record creation
public int Coins { get; set; } = 250                 // Premium currency; tied to real money
public int Gems { get; set; } = 50                   // Free currency; earned in-game
```

**Key Architectural Decisions:**

1. **Dual Primary Keys** (v2 departure from legacy)
   - `Id`: Database surrogate key; always generated by API on record creation
   - `Uuid`: Minecraft player UUID; nullable initially; unique index; set on first Minecraft join
   - **Why**: Supports multilateral create flow (web app signup before Minecraft join)

2. **Nullable Uuid Pattern**
   - User created via web app → `Id` assigned, `Uuid` = null
   - User joins Minecraft → `Uuid` captured, linked to existing `Id`, or new record created with both
   - Incentivizes early web signup (user gets `Id` before Minecraft play)

3. **Dual Currency** (v2 departure from legacy single `cash` field)
   - `Coins`: Premium currency; 1:1 mapped to real-money purchases; default 250
   - `Gems`: Free currency; earned through gameplay/tasks; default 50
   - Both non-negative integers; require special handling (see Part B)

4. **Email Field** (web app integration)
   - Supports authentication, password reset, communication
   - May be unique constraint (TBD: enforcement)
   - Not available in Minecraft-only accounts

5. **PasswordHash** (web app auth)
   - Bcrypt or similar strong hashing
   - Only relevant for web app login
   - Minecraft players authenticate via UUID on server

---

### Indexing & Lookup Strategy

**Indexes (from controller signatures):**
- Primary: `Id` (clustered index)
- Unique Index: `Uuid` (sparse; null for web-only accounts)
- Unique Index: `Username + Uuid` (composite; allows same username for different Uuids if needed, TBD)
- Index: `Email` (if unique constraint desired for web auth)
- Index: `CreatedAt` (for analytics, filtering)

**Query Patterns (from UsersController):**
- `GetUserById(int id)` → direct id lookup
- `GetUserByUuid(string uuid)` → lookup by Minecraft UUID
- `GetUserByUsername(string username)` → lookup by player name
- Supports all three because user can be found via web ID, Minecraft UUID, or username

---

## Part B: Currency System (Banking-Grade Handling)

### ⚠️ CRITICAL REQUIREMENTS: Coins & Gems Management

**Coins and Gems represent real or earned value tied to user economy.**
**All balance updates must implement banking-level safeguards.**

---

### 1. Atomic Update Constraint

**Requirement**: No partial or race-condition updates

**Implementation**:
- Use database transactions with `SERIALIZABLE` isolation level for coin updates
- Implement **Optimistic Locking** with version field:

```csharp
public int Version { get; set; } // Increment on each update
```

**Update Logic**:
```sql
UPDATE User 
SET Coins = @newCoins, Version = Version + 1 
WHERE Id = @id AND Version = @expectedVersion;

-- Returns 0 rows if version mismatch → retry or throw conflict exception
```

**Controller Handling** (from UsersController.cs):
```csharp
[HttpPut("{id:int}/coins")]
public async Task<IActionResult> UpdateCoins(int id, [FromBody] CoinUpdateDto request)
{
    try
    {
        await _service.UpdateCoinsAsync(id, request.Amount, request.TransactionType, request.Reason);
        return NoContent();
    }
    catch (ConcurrencyException)
    {
        return Conflict("Concurrent update detected; retry with fresh balance");
    }
    catch (InsufficientFundsException)
    {
        return BadRequest("Insufficient coins for this transaction");
    }
}
```

---

### 2. Audit Trail (Mandatory)

**Requirement**: Every balance change logged immutably

**Create CoinTransaction audit table:**
```
CoinTransaction
- Id: Integer (auto)
- UserId: Integer (FK → User.Id)
- TransactionType: String (Purchase, Refund, Reward, Admin, SystemAward)
- Amount: Integer (delta; positive=add, negative=remove)
- PreviousBalance: Integer (snapshot before)
- NewBalance: Integer (snapshot after)
- Reason: String (business context; e.g., "Marketplace purchase - item 42")
- Initiator: String (player, admin, system, api-token)
- Timestamp: DateTime (UTC; immutable)
- ReferenceId: String (nullable; e.g., order ID, transaction UUID)
- Status: String (Pending, Confirmed, Failed, Reversed)
```

**Audit on every balance change:**
- AddCoins(userId, amount, reason) → log +amount
- RemoveCoins(userId, amount, reason) → log -amount
- SetCoins(userId, newBalance) → log delta, but flag as suspicious if not via transaction

---

### 3. Business Logic Rules

**Rule: Balance cannot go negative**
- `RemoveCoins(id, 100)` on balance 50 → **FAIL** with `InsufficientFundsException`
- Do NOT silently clamp to 0
- Return error to client; let business layer decide (refund, retry, etc.)

**Rule: Transaction types required**
```csharp
public enum CoinTransactionType
{
    Purchase,           // Player bought something (Marketplace, items, etc.)
    Refund,            // Refund of purchase
    Reward,            // Earned through gameplay (quest, event, etc.)
    AdminGrant,        // Admin grant (testing, compensation)
    SystemAward,       // Automated system (daily bonus, etc.)
    Transfer,          // Player-to-player transfer (TBD: supported?)
    Penalty            // Forfeit (lost bet, violation, etc.)
}
```

**Rule: All coin operations require reason**
```csharp
public async Task AddCoinsAsync(int userId, int amount, CoinTransactionType type, string reason)
{
    // reason MUST be non-empty; e.g., "Quest 42 completion", "Marketplace item 999"
    // Logged for audit & support
}
```

**Rule: Gems follow same pattern but lower urgency**
- Gems are free-to-play currency; less critical than Coins
- Still require audit trail
- Audit table: GemTransaction (same schema as CoinTransaction)

---

### 4. Large Balance Change Warning

**Requirement**: Monitor/alert on unusual coin activity

**Rule: Large transactions (>1000 coins in single operation)**
- Log at WARN level (not just DEBUG)
- Include full context (user, reason, initiator)
- Possible: queue for admin review if from external API

**Rule: Rapid consecutive updates (>5 in 1 minute)**
- Log at WARN level
- Possible: rate-limit further updates from same user/session

---

### 5. Reconciliation & Audit

**Daily Reconciliation Job**:
- Sum all CoinTransaction deltas for each user
- Compare to actual User.Coins balance
- Flag discrepancies for investigation
- Cannot be auto-repaired (requires manual review)

**Monthly Audit Report**:
- Total coins earned vs. spent
- Top spenders
- Top earners
- Refunds/reversals
- Admin overrides

---

## Part C: Multilateral Create Flow (Web + Minecraft)

### Creation Pathways

**Path 1: Web App Signup First**
```
1. User POST /api/Users (UserCreateDto)
   - Username: "player123"
   - Uuid: null (not provided)
   - Email: "player@example.com"
   - PasswordHash: hashed password

2. API creates record
   - Id: 42 (auto-generated)
   - Uuid: null (to be filled later)
   - Coins: 250 (default)
   - Gems: 50 (default)
   - CreatedAt: now()

3. User logs into web app
   - Authenticates via Email + PasswordHash
   - Sees account dashboard with Uuid = null
   - Prompted: "Join Minecraft server to activate your UUID"

4. Player joins Minecraft server
   - Server sees username "player123" + UUID "abc123..."
   - Server API call: PUT /api/Users/{id}/uuid with new UUID
   - Or: Server queries by username, finds Id=42, updates UUID

5. Account fully activated
   - Id: 42, Username: player123, Uuid: abc123..., Email: player@example.com
   - User can play + access web app
```

**Path 2: Minecraft Join First** (No prior web account)
```
1. Player joins Minecraft server
   - Server sees first-time player: UUID = "xyz789..."
   - Server queries API: GET /api/Users/uuid/xyz789...
   - Returns 404 (no account yet)

2. Server triggers account creation
   - POST /api/Users (UserCreateDto)
   - Username: "player456" (from Minecraft)
   - Uuid: "xyz789..." (from Minecraft)
   - Email: null (not required for Minecraft-first)
   - PasswordHash: null (no web login yet)

3. API creates record
   - Id: 43 (auto-generated)
   - Uuid: xyz789... (set immediately)
   - Coins: 250, Gems: 50
   - CreatedAt: now()

4. Player can play immediately
   - Can later create web account (set Email + PasswordHash)
   - Sync account ID 43 with web session
```

**Path 3: Minecraft Join, User Already Has Web Account**
```
1. Web user "player123" has created account but not joined Minecraft yet
   - API has: Id=42, Uuid=null, Email, PasswordHash

2. Player joins Minecraft with same username "player123"
   - Server detects UUID "abc123..." (from Minecraft)
   - Server queries: GET /api/Users/uuid/abc123...
   - Returns 404

3. Server checks: does username match any null-Uuid accounts?
   - Queries: GET /api/Users/username/player123
   - Returns Id=42 (match!)

4. Server verifies they're same person (TBD: how?)
   - Option A: Prompt player in-game to confirm email
   - Option B: Require email verification link sent to registered email
   - Option C: Admin manual merge (risky)

5. Once verified: PUT /api/Users/42/uuid with UUID
   - Updates record: Id=42 now has Uuid=abc123...
   - Coins/Gems preserved from web account creation
```

---

## Part D: API Endpoints & DTOs (from UsersController)

### CRUD Operations

**GET /api/Users**
- Returns: `List<UserListDto>` (all users)
- Query params: TBD (pagination, filtering)
- Use-case: Admin dashboard, leaderboards

**GET /api/Users/{id}** (by database ID)
- Path param: `id: int`
- Returns: `UserDto` (full user details)
- Response:
  ```json
  {
    "id": 42,
    "username": "player123",
    "uuid": "abc123...",
    "email": "player@example.com",
    "coins": 500,
    "createdAt": "2025-01-07T10:30:00Z"
  }
  ```

**GET /api/Users/uuid/{uuid}** (by Minecraft UUID)
- Path param: `uuid: string`
- Returns: `UserSummaryDto` (lightweight, safe for public)
- Use-case: Minecraft server lookups (minimal data exposure)
  ```json
  {
    "id": 42,
    "username": "player123",
    "uuid": "abc123...",
    "coins": 500
  }
  ```

**GET /api/Users/username/{username}** (by player name)
- Path param: `username: string`
- Returns: `UserSummaryDto`
- Use-case: Leaderboards, player search

**POST /api/Users** (Create new account)
- Request body: `UserCreateDto`
  ```json
  {
    "username": "newplayer",
    "uuid": null,  // optional; can be null for web signup
    "email": "player@example.com",
    "createdAt": "2025-01-07T10:30:00Z"
  }
  ```
- Response: 201 Created → `UserDto` (full record with assigned Id)
- Business logic:
  - Generate Id (auto-increment or GUID)
  - Set default Coins=250, Gems=50
  - Hash password if provided (TBD: in UserCreateDto?)
  - Validate username unique (or username+uuid)
  - Log to audit trail

**PUT /api/Users/{id}** (Update user profile)
- Path param: `id: int`
- Request body: `UserDto` (partial update; TBD: confirm fields)
- Response: 204 No Content
- Allowed updates: Email, PasswordHash, Username (TBD: confirm)
- NOT via this endpoint: Coins, Gems, Uuid, CreatedAt

**DELETE /api/Users/{id}** (Soft or hard delete)
- Path param: `id: int`
- Response: 204 No Content
- TBD: Soft delete (flag IsActive=false) or hard delete?
- TBD: Cascade to CoinTransaction audit records?

---

### Currency Operations (Banking-Grade)

**PUT /api/Users/{id}/coins** (Update coins by database ID)
- Path param: `id: int`
- Request body: `CoinUpdateDto` (TBD: define)
  ```json
  {
    "amount": 100,
    "transactionType": "Reward",
    "reason": "Quest 42 completion",
    "expectedVersion": 5  // for optimistic locking
  }
  ```
- Response: 204 No Content on success
- Errors:
  - 409 Conflict: version mismatch (retry)
  - 400 Bad Request: insufficient funds (if RemoveCoins)
  - 400 Bad Request: invalid reason/type

**PUT /api/Users/{uuid}/coins** (Update coins by Minecraft UUID)
- Path param: `uuid: string`
- Request body: `CoinUpdateDto`
- Response: 204 No Content
- Use-case: Minecraft server calling directly with UUID (faster than id lookup)

**Note**: No `GET .../coins` endpoint for security (use GET /api/Users/{id} to retrieve full user including balance)

---

### Search & List

**POST /api/Users/search** (Paged search)
- Request body: `PagedQueryDto`
  ```json
  {
    "pageNumber": 1,
    "pageSize": 20,
    "query": "player123",
    "sortBy": "username"
  }
  ```
- Response: `PagedResultDto<UserListDto>`
  ```json
  {
    "totalCount": 150,
    "pageNumber": 1,
    "pageSize": 20,
    "items": [
      { "id": 42, "username": "player123", "uuid": "...", "coins": 500 }
    ]
  }
  ```
- Use-case: Admin dashboards, leaderboards, player directories

---

## Part E: DTOs (Data Transfer Objects)

### UserCreateDto (Web signup)
```csharp
public class UserCreateDto
{
    public string Username { get; set; }           // Required
    public Guid? Uuid { get; set; }                // Optional; null for web signup
    public string Email { get; set; }              // Optional for Minecraft-first
    public DateTime CreatedAt { get; set; }        // Default: DateTime.UtcNow
    // PasswordHash: NOT in DTO; handled by auth service
}
```

### UserDto (Full user record)
```csharp
public class UserDto
{
    public int Id { get; set; }
    public string Username { get; set; }
    public string Uuid { get; set; }
    public string Email { get; set; }
    public int Coins { get; set; }
    public string CreatedAt { get; set; }  // ISO 8601 string
    // PasswordHash: NOT in DTO (never expose)
}
```

### UserSummaryDto (Lightweight; public-safe)
```csharp
public class UserSummaryDto
{
    public int Id { get; set; }
    public string Username { get; set; }
    public string Uuid { get; set; }
    public int Coins { get; set; }
    // No Email, PasswordHash, Gems (if sensitive)
}
```

### UserListDto (Search results)
```csharp
public class UserListDto
{
    public int? Id { get; set; }
    public string Username { get; set; }
    public string Uuid { get; set; }
    public string Email { get; set; }
    public int Coins { get; set; }
    // Minimal set for list display
}
```

### CoinUpdateDto (Currency transaction) - TBD
```csharp
public class CoinUpdateDto
{
    public int Amount { get; set; }                       // Delta to add/remove
    public string TransactionType { get; set; }           // "Purchase", "Reward", etc.
    public string Reason { get; set; }                    // Business context
    public int? ExpectedVersion { get; set; }             // For optimistic locking
    public string? Initiator { get; set; }                // Who triggered this (optional; default current user)
}
```

---

## Part F: Session & Gameplay Integration

### Login/Logout Session

(Inherited from legacy SPEC_USER.md Part B; follows same pattern)

**On Minecraft Join:**
1. Server fetches User by UUID or creates new
2. Sets transient Player reference
3. Creates UserLogin event
4. Increments statistics.logins
5. Initializes/validates daily statistics

**On Logout:**
1. Records logout timestamp
2. Persists play time
3. Updates statistics
4. Flushes any pending coin changes to database

---

### Statistics & Achievement Tracking

(Inherited from legacy SPEC_USER.md Part B)

**Cumulative stats** (lifetime):
- logins, kills, deaths, wins, earnings, etc.

**Daily stats** (snapshot):
- Resets at midnight or on day change
- Enables daily challenges, streaks, leaderboards

---

## Part G: Validation & Security

### Input Validation

**Username**:
- Required, non-empty
- Max 256 characters
- Alphanumeric + underscore/dash (TBD: regex)
- Unique across active accounts (TBD: case-sensitive?)

**UUID**:
- If provided, must be valid UUID format (36 chars, hyphens)
- If null, system allows (web signup path)
- Once set, immutable (no changing UUID)

**Email**:
- Optional for Minecraft-only accounts
- If provided, valid email format
- Unique (if multiple accounts with same email disallowed)

**Coins/Gems**:
- Non-negative integers only
- Update only via dedicated endpoint (not direct DTO assignment)
- Amount in request must be validated (e.g., -100 to -1000 for remove is OK, but -999999 might be suspicious)

**PasswordHash**:
- Never exposed in DTOs
- Never accepted in UserCreateDto or UserDto (only via separate /auth/login endpoint, TBD)

---

### Security Considerations

1. **No password in DTOs**: All auth handled separately via token/session mechanism

2. **UUID not secret**: Safe to expose (it's a public Minecraft UUID)

3. **Email privacy**: Should not be in UserSummaryDto or public leaderboards

4. **Coins are sensitive**: 
   - Update endpoint requires authentication (user can only modify own account or admin)
   - All changes audited
   - Rate-limited

5. **Concurrent access**: Optimistic locking on User.Version prevents stale updates

---

## Part H: Minecraft Plugin Integration

### Plugin-to-API Communication

**On Player Join** (from knk-plugin-v2):
```
1. Plugin calls: GET /api/Users/uuid/{playerUuid}
   → Returns UserSummaryDto or 404

2. If 404: Plugin calls POST /api/Users with username + uuid + email=null
   → Returns UserDto with new Id

3. If found: Plugin loads User context
   → Deserializes Id, Username, Coins, Gems
   → Creates runtime User object for gameplay

4. During gameplay:
   → Plugin calls PUT /api/Users/{uuid}/coins for transactions
   → Reason: "Marketplace purchase", "Quest reward", etc.

5. On player logout:
   → Plugin may call PUT /api/Users/{id} to sync updated stats (TBD)
```

**Considerations**:
- All API calls must include auth token (TBD: JWT, API key, etc.)
- Minecraft server should cache User object in memory (reduce API calls)
- Cache invalidation strategy: TBD (TTL, event-based, etc.)

---

## Part I: Known TBDs & Decisions Pending

1. **Username uniqueness scope**: 
   - Globally unique? Or unique per UUID?
   - Can two Minecraft players have same username if different UUIDs? (Legacy: probably not allowed)

2. **Email uniqueness**:
   - Globally unique if present?
   - Required for web app auth?

3. **Soft vs Hard Delete**:
   - Should deleted users remain in audit trail?

4. **Password handling**:
   - Separate auth endpoint for web app login? (/auth/login)
   - How to initially set password during web signup?

5. **Rate limiting**:
   - Coins/Gems updates limited per minute/hour?
   - Configurable thresholds?

6. **Transaction reversal**:
   - Can admins reverse a coin transaction?
   - Leaves original transaction + reversal record?

7. **Account merging**:
   - If web user later joins with different Minecraft name, how to merge?

8. **Gems audit table**:
   - Required or optional? (Coins deemed critical, Gems might not need audit)

9. **Initiator field in audit**:
   - Track which admin/system/API-token initiated change?
   - Useful for support/debugging?

10. **Leaderboards**:
    - Should they include null-Uuid accounts (web-only)?
    - Time windows: all-time, monthly, weekly, daily?

---

## Appendix: Model Comparison (Legacy vs v2)

| Feature | Legacy (knk v1) | v2 API |
|---------|-----------------|---------|
| Primary Key | UUID | Id (int) |
| UUID field | @Id, required, immutable | Unique index, nullable initially |
| Username | Max 256, required | Max 256, required |
| Currency | `cash: int` (single) | `coins: int` + `gems: int` (dual) |
| Default currency | 100 | coins=250, gems=50 |
| Email | N/A | Optional string |
| Password | N/A | PasswordHash (for web auth) |
| Session tracking | UserLogin entity | Same pattern |
| Statistics | UserStatistics + UserStatisticsDaily | Same pattern (TBD: v2 implementation) |
| Audit trail | None (TBD: implement) | **Mandatory for Coins/Gems** |
| Optimistic locking | N/A | Version field required |
| Creation paths | Minecraft only | Web + Minecraft (multilateral) |

---

## References

**Source Files:**
- `/Repository/knkwebapi_v2/Models/User.cs`
- `/Repository/knkwebapi_v2/Controllers/UsersController.cs`
- `/Repository/knkwebapi_v2/Dtos/UserDtos.cs`
- `/Repository/knk-plugin-v2/spec/SPEC_USER.md`

**Legacy Source Files:**
- `/Repository/knk/src/main/java/net/knightsandkings/model/user/User.java`
- `/Repository/knk/src/main/java/net/knightsandkings/model/user/UserStatistics.java`
